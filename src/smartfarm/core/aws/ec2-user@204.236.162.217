# ga_lambda.py
import json, boto3, numpy as np
from ga_core import fitness, GAContext

s3 = boto3.client("s3")  # S3 is global; bucket is in us-west-1

def _read_json_s3(uri):
    bucket, key = uri[5:].split("/", 1)
    obj = s3.get_object(Bucket=bucket, Key=key)
    return json.loads(obj["Body"].read())

def _write_json_s3(uri, payload):
    bucket, key = uri[5:].split("/", 1)
    s3.put_object(Bucket=bucket, Key=key, Body=json.dumps(payload).encode(), ContentType="application/json")

def _np(x): return np.array(x, dtype=float)

# ga_lambda.py (only the handler body changes)
def lambda_handler(event, _):
    spec_s3   = event["spec_s3"]              # s3://.../spec/gen_N.json
    out_prefix= event["out_prefix"]           # s3://.../results
    gen       = int(event["generation"])
    start     = int(event.get("start", 0))    # chunk start index
    count     = int(event.get("count", 1))    # how many to do in this chunk

    # Back-compat: support old single-index or new chunked API
    if "index" in event:
        start = int(event["index"])
        count = 1
    else:
        start = int(event.get("start", 0))
        count = int(event.get("count", 1))

    spec = _read_json_s3(spec_s3)
    pop  = [ _np(v) for v in spec["population"] ]
    c    = spec["ctx"]
    ctx  = GAContext(
        dt=c["dt"], simulation_hours=c["simulation_hours"], total_time_steps=c["total_time_steps"],
        h0=c["h0"], A0=c["A0"], N0=c["N0"], c0=c["c0"], P0=c["P0"],
        precipitation=_np(c["precipitation"]), temperature=_np(c["temperature"]), radiation=_np(c["radiation"]),
        WC_opt=c["WC_opt"], FC_opt=c["FC_opt"], T_typ=c["T_typ"], R_typ=c["R_typ"],
        ah=c["ah"], aA=c["aA"], aN=c["aN"], ac=c["ac"], aP=c["aP"],
        kh=c["kh"], kA=c["kA"], kN=c["kN"], kc=c["kc"], kP=c["kP"],
        w1=c["w1"], w2=c["w2"]
    )

    end = min(start + count, len(pop))
    indices, costs = [], []
    for i in range(start, end):
        indices.append(i)
        costs.append(float(fitness(pop[i], ctx)))

    _write_json_s3(f"{out_prefix}/gen_{gen}/part_{start}.json",
                   {"indices": indices, "costs": costs})
    return {"ok": True, "start": start, "end": end, "n": len(indices)}
